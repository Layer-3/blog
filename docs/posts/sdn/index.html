<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.65.3" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark">

<link rel="icon" type="image/png" sizes="16x16" href="/favicon.png">
<link rel="shortcut icon" href="/favicon.png" type="image/x-icon"><title>软件定义网络&nbsp;&ndash;&nbsp;Layer 7</title><link rel="stylesheet" href="/css/core.min.13b7b2b0d13bb838fbc41a20885a38553de7e0fbe92f6c06ab1422828ff749227cb9f9974d563cb370caaa928d3b03c9.css" integrity="sha384-E7eysNE7uDj7xBogiFo4VT3n4PvpL2wGqxQigo/3SSJ8ufmXTVY8s3DKqpKNOwPJ"><body>
    <div class="base-body"><section id="header" class="site header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/favicon.png" alt /><span class="site name">Layer 7</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about/">About</a><a class="nav item" href="https://gohugo.io/"target="_blank">Hugo</a></nav></div></span></div><div class="site slogan"><span class="title">Thanks for layer 3</span></div></section><div id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">软件定义网络</h1><p class="article date">Mar 22, 2020<span class="lastmod"> • edited Mar 26, 2020</span></p></section><article class="article markdown-body"><p><em>软件定义网络即 SDN，是我一直以来想要研读的一个方向，在完成了 NSFC 的申请书之后，终于闲了一些，决定从头开始，先对 SDN 有个初步的了解，然后再深入进去，进行查缺补漏式的系统学习，以开展相应的研究和实验。目前第一步已经看完了 OpenFlow 的开山之作，具体可以看这篇<a href="https://www.ansont.cn/posts/openflow"target="_blank">博文</a>，这篇博文主要是阅读 SDN 的一篇综述“Softwoare-Defined Networking: A Comprehensive Survey”的学习总结</em></p>
<hr>
<h2 id="1-dot-为什么">1. 为什么</h2>
<p>在介绍 SDN 之前，需要先说明为什么需要 SDN，也就是现在的网络架构有什么问题？</p>
<ul>
<li>传统的 IP 网络太<code>复杂</code>难以管理、配置和实施高层策略。（管理员要针对每个设备根据设备厂商的不同慢慢配置）</li>
<li>现有的网络在垂直层面是<code>紧耦合</code>的，也就是控制层和数据层是在交换机和路由器这些网络设备上绑定在一起的，这就很不 flexibility 了，并且这也让网络协议的更新换代变得十分困难。</li>
</ul>
<p>SDN 为改变上面的问题，做了哪些工作呢？</p>
<ul>
<li><code>分离</code>控制层与数据层，也就是把控制逻辑从转发流量的步骤中拿了出来。</li>
<li>网络中的路由器就只是简单的转发设备，而控制逻辑放在逻辑上中心化<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>的控制设备上，也就简化了配置和迭代。</li>
</ul>
<h2 id="2-dot-介绍">2. 介绍</h2>
<h3 id="2-dot-1-网络的拆分">2.1 网络的拆分</h3>
<p>计算机网络可以被分为三层：</p>
<ul>
<li>管理层：监测和配置管理层，<strong>定义网络策略</strong>；</li>
<li>控制层：表示管理数据层元素的转发表的协议，<strong>实施(enforce)策略</strong>；</li>
<li>数据层：用来转发数据，<strong>通过转发相应的数据来执行(excutes)策略</strong>。</li>
</ul>
<span class="image-container"><span class="link" ><a href="/ox-hugo/2020-03-23_22-02-16_screen-shoot.png" 
        target="_blank"><img class="img" src="/ox-hugo/2020-03-23_22-02-16_screen-shoot.png" width="300"/></a></span>
</span>
<h3 id="2-dot-2-什么是-sdn">2.2 什么是 SDN</h3>
<h4 id="2-dot-2-dot-1-基本构成">2.2.1 基本构成</h4>
<p>文章认为 SDN 的架构由四大支柱构成：</p>
<ol>
<li>控制与数据层分离；</li>
<li>转发决策是基于 flow 的，而不是基于目的地址的。flow 这个抽象使得不同类型的网络设备（比如路由器、交换机、防火墙等）可以统一行为，极大的增加了灵活性（但可能受到流表<code>功能</code>上的限制？）；</li>
<li>控制逻辑被移动到外部实体，被称之为 SDN Controller 或者 NOS<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>，可以基于此抽象对转发设备进行编程；</li>
<li>网络可以通过运行在 NOS(其与数据层设备交互) 之上的软件程序来进行编程。</li>
</ol>
<h4 id="2-dot-2-dot-2-抽象的方法">2.2.2 抽象的方法</h4>
<p>通过抽象的方法可以帮助我们更好地理解计算机科学中的很多事物，SDN 也不例外。SDN 可以被认为是由三大抽象构成的：</p>
<ul>
<li><code>Forwarding abstraction</code> ，可以类比于 OS 中的驱动，实现网络程序要求的各种转发行为；</li>
<li><code>Distribution abstraction</code> ，所有的分布式系统都依赖于网络，而实际上，网络本身就是个大的分布式系统，所以通过这个通用的 Distribution Layer（比如 NOS），来处理分布式系统中的状态，提供一个中心化的使用体验。具体来说需要具有两大功能：
<ul>
<li>给转发设备安装控制指令(installing the control commands on the forwarding devices)；</li>
<li>收集转发层(forwarding layer)层的状态信息，从而给网络应用提供一种全局的 view。</li>
</ul>
</li>
<li><code>Specification abstraction</code> ，让网络应用可以表达它希望网络执行的行为而不用具体实现该行为。通过虚拟化或者编程语言的方式来实现，文章中说是把抽象的配置（configuration)映射到由 SDN 控制器暴露出来的全局网络的实际的物理配置上，(<em>这么看确实像程序语言干的事，此处未完全理解，存疑</em>)。</li>
</ul>
<span class="image-container"><span class="link" ><a href="https://i.loli.net/2020/03/23/V6u9bo8CSU35TwD.png" 
        target="_blank"><img class="img" src="https://i.loli.net/2020/03/23/V6u9bo8CSU35TwD.png" width="400"/></a></span>
</span>
<h4 id="2-dot-2-dot-3-术语定义">2.2.3 术语定义</h4>
<ol>
<li><code>Forwarding Devices(FD)</code>，用来执行的一些基本操作的数据层设备，其拥有一些实现定义好的指令集（比如转发到和端口之类的），这些指令集实际上由南向接口 southbound interfaces 定义的，并由 SDN 控制器安装在转发设备中以实现南向协议；</li>
<li><code>Data Plane(DP)</code>，网络中的转发设备的集合就是一个数据层，这里的集合表示这些设备是通过无线或有线连接着的；</li>
<li><code>Southbound Interface(SI)</code>，主要用来表示控制层与数据层之间的交互；
<ul>
<li>FD 中的指令集就是由南向 API 定义的，南向 API 是 SI 的一部分；</li>
<li>定义控制层与 SD 之间的通信协议。</li>
</ul>
</li>
<li><code>Control Plane(CP)</code>，FD 是被 CP 通过 SI 实体来编程的，相当于是网络的大脑，所有的逻辑都在应用程序和控制器中，也就是在控制层中；</li>
<li><code>Northbound Interface(NI)</code>，NOS 给 APP 开发者提供 API，这个 API 就是 NI，本质上，NI 通常对 SI 使用的底层的指令集进行抽象，来对 FD 进行编程；</li>
<li><code>Management Plane(MP)</code>，利用 NI 提供的功能（函数）来实现网络控制和操作逻辑的应用程序集合，（包括路由、防火墙等等），管理程序定义策略，这些策略被最终翻译为南向的特定指令，来编程 FD 的行为。</li>
</ol>
<h2 id="3-dot-software-defined-networks">3. Software-defined Networks</h2>
<h3 id="3-dot-1-infrastructure">3.1 Infrastructure</h3>
<p>下图表示了基于 OpenFlow 的 SDN 设备的结构和逻辑
<a target="_blank" rel="noopener noreferrer" 
  href="https://gitee.com/layer3/pic/raw/master/uPic/screen-shoot%204.png"><img  src="https://gitee.com/layer3/pic/raw/master/uPic/screen-shoot%204.png"
        alt/></a></p>
<p>Infrastructure 主要介绍的是那时支持 SDN 设备的基本构成，基本在上图可以看到，不过值得注意的是这样一个事实：</p>
<blockquote>
<p>软件实现的交换机是一个实现数据中心网络和网络虚拟化的很有前景的想法。e.g. Switch light, ofsoftswitch, Open vSwitch, Pica8, Pantou, XorPlus。</p>
</blockquote>
<p>我觉的这是一个值得研究的点，如果目前还是一个“很有前景的“而不是非常完善的领域的话。</p>
<h3 id="3-dot-2-southbound-interfaces">3.2 Southbound Interfaces</h3>
<p>或者叫<code>Southbound APIs</code>，作为连接 FD 和 Control 的桥梁，非常重要。与 OpenFlow 提出时想要解决的问题一样，这些 API 目前还是和 FD 的底层物理实现或虚拟设施等紧相关。传统的设备各个厂商之间的实现方法不同，API 不通用，使用诸如 OpenFlow 这样的南向 API 可以为不同厂商生产的 OpenFlow-enabled 的设备带来互操作性(interoperability)。作为数据和控制层之间的通信笑到，OpenFlow 协议为 NOS 提供三种信息通道：</p>
<ul>
<li>当链路或端口变化被发现时，FD 给 controller 发送的基于<code>事件</code>的 message；</li>
<li>FD 生成的<code>统计数据</code>发送给 Controller 以收集统计；</li>
<li>当转发设备不知道如何处理<code>新</code> 的传入流时，或者由于流表的匹配条目中有明确的“<code>发送到控制器</code>”操作，packet-in messages 将由转发设备发送到控制器。</li>
</ul>
<p><code>这些信息通道是给NOS提供*流级别*信息的基本手段</code></p>
<p>下面概述在南向 API 方面的探索。本质上是为转发设备提供一种可编程的接口，一些探索是为了给 OpenFlow 纠偏，另一些则是根本上的新思路。</p>
<ul>
<li><code>ForCES</code>，将控制和数据分离，但是仍然在一个网络设备中；</li>
<li><code>OVSDB</code>，相当于 OpenFlow 的补充协议，可以提供更多功能（诸如 QoS 策略，控制 OpenFlow 数据路径的信道接口等）；</li>
<li><code>POF</code>，为了加强 SDN 的转发层。在 OpenFlow 里面，转发设备必须对头部进行解析来找到与流表条目匹配的数据位，这意味着数据层设备需要为此花费严重，同时 OpenFlow 的更新换代，对头部的解析就更困难了。为此 POF 提出了一种 generic flow instruction set(FIS)，是的转发设备像是一个只有处理和转发能力的白盒，<code>包解析任务由控制器来完成</code>，返回给转发设备一系列 Keys 和查表指令（安装在转发设备中的）；</li>
<li><code>OpFlex</code>，把一部分网络管理功能<code>返还给转发设备</code>，这体现了 SDN 中的一个问题：就在什么地方放置哪些功能？</li>
<li><code>OpenState</code>，用<code>有限状态机</code>来让转发设备执行几个有状态任务，而<strong>不会增加控制平面的复杂性或开销</strong>，这使的所有只涉及本地状态的任务（比如 MAC 地址学习操作）可以直接在转发设备中执行，而不用和三控制器通信；</li>
<li><code>ROFL</code>，其直接提供了一种抽象层，隐藏各种版本的 OpenFlow 协议的区别；</li>
<li><code>HAL</code>，其准确来说不算是南向 API，它更像是属于转发设备和南向 API 直接的那一层，作为一个<strong>翻译器</strong>将诸如 OpenFlow 这样的南向 API 翻译后来控制硬件设备；</li>
<li><code>PAD</code>，通过使用通用字节操作、定义协议头和提供功能定义来控制数据路径行为，从而对转发设备进行更通用的编程。</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>说逻辑上中心化，是因为物理上大多是分布式实现的，因为中心化的控制设备会带来很多问题，比如单点故障、性能扩展性不佳等。 <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>一个运行在商品服务器技术上的软件平台，它基于逻辑上集中的抽象网络视图提供必要的资源和抽象，以促进转发设备的编程。 <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
</article><section class="article labels"><a class="category" href=/categories/study/>Study</a><a class="tag" href=/tags/sdn/>SDN</a><a class="tag" href=/tags/network/>Network</a></section></div><section class="article navigation"><p><a class="link" href="/posts/expression/"><span class="li">&larr;</span>Expression</a></p><p><a class="link" href="/posts/openflow/"><span class="li">&rarr;</span>OpenFlow</a></p></section><section class="article discussion"><div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ansont-cn" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></section></div><section id="footer" class="footer"><div class="footer-wrap">
    <p class="copyright">©2020 TW.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section><script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script>
        <script
            type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-161408542-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</div>
</body>

</html>